<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Grid Pendulums with Permanent Trails and Force</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; background: #000; }
    #controls {
      position: fixed; top: 10px; left: 10px; background: rgba(25,25,25,0.9); color: #fff;
      padding: 10px 18px; border-radius: 10px; z-index:10; font-family: sans-serif;
      box-shadow: 0 2px 12px #000c;
      user-select: none;
    }
    #controls label { margin-right: 6px; }
    #controls input[type=range] { width: 80px; }
  </style>
</head>
<body>
<div id="controls">
  <label>Gravity: <input id="gravity" type="range" min="0" max="2" step="0.01" value="0.4"></label>
  <label>Speed: <input id="speed" type="range" min="0.1" max="2" step="0.01" value="1"></label>
  <label>Pendulums: <input id="numPendulums" type="number" min="1" max="20" value="6" style="width:42px"></label>
  <label>Segments: <input id="numSegments" type="number" min="1" max="15" value="5" style="width:42px"></label>
  <button id="reset">Reset</button>
  <button id="clearTrails">Clear Trails</button>
</div>
<canvas id="pendulum-canvas"></canvas>
<script>
// Canvas setup
const canvas = document.getElementById('pendulum-canvas');
const ctx = canvas.getContext('2d');
let w = window.innerWidth, h = window.innerHeight;
canvas.width = w; canvas.height = h;

// Controls
const gravityRange = document.getElementById('gravity');
const speedRange = document.getElementById('speed');
const pendulumsInput = document.getElementById('numPendulums');
const segmentsInput = document.getElementById('numSegments');
const resetBtn = document.getElementById('reset');
const clearTrailsBtn = document.getElementById('clearTrails');

// Parameters
let GRAVITY = parseFloat(gravityRange.value);
let SPEED = parseFloat(speedRange.value);
let NUM_PENDULUMS = parseInt(pendulumsInput.value,10);
let SEGMENTS_PER_PENDULUM = parseInt(segmentsInput.value,10);
const GLOW_BLUR = 16;
const SEGMENT_LENGTH = () => Math.min(w, h) / (SEGMENTS_PER_PENDULUM * 2.5);

// Mouse
let mouse = { x: -1000, y: -1000, down: false, dragging: null, dragType: null, dragIndex: null, offsetX: 0, offsetY: 0 };

// Utility
function dist(a, b) { return Math.hypot(a.x-b.x, a.y-b.y); }
function clamp(val, min, max) { return Math.max(min, Math.min(val, max)); }
function lerp(a,b,t){return a + (b-a)*t;}
function randomColor() {
  // Random saturated color
  let h = Math.floor(Math.random()*360);
  return `hsl(${h}, 80%, 55%)`;
}

// Grid placement logic
function gridPositions(n, areaW, areaH, centerX, centerY) {
  let cols = Math.ceil(Math.sqrt(n)),
      rows = Math.ceil(n / cols),
      positions = [],
      cellW = areaW / cols,
      cellH = areaH / rows,
      startX = centerX - areaW/2 + cellW/2,
      startY = centerY - areaH/2 + cellH/2;
  for (let i=0; i<n; ++i) {
    let row = Math.floor(i/cols), col = i % cols;
    positions.push({
      x: startX + col*cellW,
      y: startY + row*cellH
    });
  }
  return positions;
}

// Classes
class PendulumSegment {
  constructor(length, angle) {
    this.length = length;
    this.angle = angle;
    this.aVel = 0;
    this.aAcc = 0;
  }
}
class Pendulum {
  constructor(origin, numSegments, color) {
    this.origin = {...origin};
    this.segments = [];
    for (let i=0;i<numSegments;++i)
      this.segments.push(new PendulumSegment(
        SEGMENT_LENGTH(),
        lerp(Math.PI/3,2*Math.PI/3,Math.random())
      ));
    this.trail = []; // permanent trail
    this.color = color;
  }
  // Forward kinematics: returns array of points [origin, ..., tip]
  getPoints() {
    let pts = [this.origin];
    let x = this.origin.x, y = this.origin.y, angle = 0;
    for (let seg of this.segments) {
      angle += seg.angle;
      x += seg.length * Math.sin(angle);
      y += seg.length * Math.cos(angle);
      pts.push({x, y});
    }
    return pts;
  }
  // Physics update: includes collision with mouse
  update(gravity, speed) {
    let pts = this.getPoints();
    // Mouse block logic (treat mouse as a circle)
    for (let i = 0; i < pts.length-1; ++i) {
      let nearest = nearestPointOnSegment(mouse, pts[i], pts[i+1]);
      if (dist(mouse, nearest) < 22) {
        let v = {x: pts[i+1].x - mouse.x, y: pts[i+1].y - mouse.y};
        let len = Math.hypot(v.x, v.y);
        if (len < 22) {
          v.x *= (22/len); v.y *= (22/len);
          pts[i+1].x = mouse.x + v.x;
          pts[i+1].y = mouse.y + v.y;
          let prev = pts[i];
          let dx = pts[i+1].x - prev.x;
          let dy = pts[i+1].y - prev.y;
          let newAngle = Math.atan2(dx, dy);
          let angleSum = 0;
          for (let j=0;j<=i;++j) angleSum += this.segments[j].angle;
          let diff = newAngle - angleSum;
          this.segments[i].angle += diff;
          this.segments[i].aVel *= 0.5;
        }
      }
    }
    // Standard physics
    for (let i=0;i<this.segments.length;++i) {
      let seg = this.segments[i], totalAngle = 0;
      for (let j=0;j<=i;++j) totalAngle += this.segments[j].angle;
      seg.aAcc = -gravity / seg.length * Math.sin(totalAngle);
      seg.aVel += seg.aAcc * speed;
      seg.aVel *= 0.995;
      seg.angle += seg.aVel * speed;
    }
  }
  // Draw pendulum and trail
  draw(ctx) {
    let pts = this.getPoints();

    // Permanent Trail
    this.updateTrail(pts[pts.length-1]);
    this.drawTrail(ctx);

    // Draw segments
    ctx.save();
    ctx.shadowBlur = GLOW_BLUR;
    ctx.shadowColor = this.color;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 8;
    for (let i=0;i<pts.length-1;++i) {
      ctx.beginPath();
      ctx.moveTo(pts[i].x, pts[i].y);
      ctx.lineTo(pts[i+1].x, pts[i+1].y);
      ctx.stroke();
      // Joint
      ctx.beginPath();
      ctx.arc(pts[i+1].x, pts[i+1].y, 11, 0, 2*Math.PI);
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.fill();
    }
    // Draw base vertex as a large white circle if hovered
    ctx.beginPath();
    ctx.arc(this.origin.x, this.origin.y, 18, 0, 2*Math.PI);
    ctx.fillStyle = dist(mouse, this.origin)<20 ? '#fff' : '#aaa';
    ctx.shadowBlur = GLOW_BLUR*1.3;
    ctx.shadowColor = "#fff";
    ctx.fill();
    ctx.restore();
  }
  // Add tip to permanent trail only if moved significantly
  updateTrail(pt){
    if (this.trail.length === 0 || dist(pt, this.trail[this.trail.length-1]) > 2)
      this.trail.push({x: pt.x, y: pt.y});
  }
  drawTrail(ctx) {
    if (this.trail.length < 2) return;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = 'rgba(255,255,255,0.93)';
    ctx.beginPath();
    ctx.moveTo(this.trail[0].x, this.trail[0].y);
    for (let i=1; i<this.trail.length; ++i) {
      ctx.lineTo(this.trail[i].x, this.trail[i].y);
    }
    ctx.stroke();
    ctx.restore();
  }
  clearTrail() {
    this.trail = [];
  }
}

// Helper: Closest point on segment ab to point p
function nearestPointOnSegment(p, a, b) {
  let dx = b.x-a.x, dy = b.y-a.y;
  if (dx===0 && dy===0) return {x:a.x, y:a.y};
  let t = ((p.x-a.x)*dx + (p.y-a.y)*dy)/(dx*dx + dy*dy);
  t = clamp(t, 0, 1);
  return {x: a.x + t*dx, y: a.y + t*dy};
}

// Pendulums array and reset
let pendulums = [];
function resetPendulums() {
  pendulums = [];
  let gridAreaW = w * 0.6, gridAreaH = h * 0.6;
  let positions = gridPositions(NUM_PENDULUMS, gridAreaW, gridAreaH, w/2, h/2);
  for (let i=0; i<NUM_PENDULUMS; ++i) {
    let color = randomColor();
    pendulums.push(new Pendulum(
      positions[i],
      SEGMENTS_PER_PENDULUM,
      color
    ));
  }
}
window.addEventListener('resize', ()=>{
  w = window.innerWidth; h = window.innerHeight;
  canvas.width = w; canvas.height = h;
  resetPendulums();
});

// --- Mouse Interactivity for Drag/Force --- //
canvas.addEventListener('mousedown', e => {
  mouse.down = true;
  // Try to drag origin first
  for (let p of pendulums) {
    if (dist(mouse, p.origin) < 20) {
      mouse.dragging = p;
      mouse.dragType = 'origin';
      mouse.offsetX = p.origin.x - mouse.x;
      mouse.offsetY = p.origin.y - mouse.y;
      return;
    }
  }
  // Try to drag a segment for force
  for (let p of pendulums) {
    let pts = p.getPoints();
    for (let i = 1; i < pts.length; ++i) { // skip origin
      if (dist(mouse, pts[i]) < 16) {
        mouse.dragging = p;
        mouse.dragType = 'segment';
        mouse.dragIndex = i-1; // segment index
        mouse.startPos = {x: pts[i].x, y: pts[i].y};
        mouse.lastPos = {x: mouse.x, y: mouse.y};
        return;
      }
    }
  }
});
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  // If dragging, update
  if (mouse.down && mouse.dragging) {
    if (mouse.dragType === 'origin') {
      mouse.dragging.origin.x = mouse.x + mouse.offsetX;
      mouse.dragging.origin.y = mouse.y + mouse.offsetY;
    }
  }
});
canvas.addEventListener('mouseup', e => {
  // If dragging a segment, apply force as impulse
  if (mouse.down && mouse.dragging && mouse.dragType === 'segment') {
    let p = mouse.dragging;
    let pts = p.getPoints();
    let idx = mouse.dragIndex;
    // Calculate drag delta as velocity
    let dx = mouse.x - mouse.lastPos.x;
    let dy = mouse.y - mouse.lastPos.y;
    let force = Math.sqrt(dx*dx+dy*dy)*0.04;
    if (force > 0) {
      // Apply impulse to angle velocity
      let seg = p.segments[idx];
      // Impulse direction: perpendicular to segment
      let segAngle = 0;
      for (let i=0;i<=idx;++i) segAngle += p.segments[i].angle;
      // Calculate perpendicular impulse (cross product)
      let impulse = ((dx * Math.cos(segAngle)) - (dy * Math.sin(segAngle))) * 0.10;
      seg.aVel += impulse;
    }
  }
  mouse.down = false;
  mouse.dragging = null;
  mouse.dragType = null;
  mouse.dragIndex = null;
  mouse.offsetX = 0; mouse.offsetY = 0;
});
canvas.addEventListener('mouseleave', e => {
  mouse.x = -1000; mouse.y = -1000; mouse.down = false; mouse.dragging = null; mouse.dragType = null; mouse.dragIndex = null;
});

// Controls
gravityRange.addEventListener('input', ()=>{ GRAVITY = parseFloat(gravityRange.value); });
speedRange.addEventListener('input', ()=>{ SPEED = parseFloat(speedRange.value); });
pendulumsInput.addEventListener('change', ()=>{
  NUM_PENDULUMS = parseInt(pendulumsInput.value,10);
  resetPendulums();
});
segmentsInput.addEventListener('change', ()=>{
  SEGMENTS_PER_PENDULUM = parseInt(segmentsInput.value,10);
  resetPendulums();
});
resetBtn.addEventListener('click', resetPendulums);
clearTrailsBtn.addEventListener('click', () => {
  for (let p of pendulums) p.clearTrail();
});

// Animation
function animate() {
  ctx.clearRect(0,0,w,h);
  for (let p of pendulums) {
    if (!mouse.dragging || mouse.dragging !== p || mouse.dragType !== 'origin')
      p.update(GRAVITY, SPEED);
    p.draw(ctx);
  }
  requestAnimationFrame(animate);
}

// Init
resetPendulums();
animate();

</script>
</body>
</html>\
