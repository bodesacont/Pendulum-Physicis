<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Interactive Rainbow Pendulums</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; background: #000; }
    #controls {
      position: fixed; top: 10px; left: 10px; background: rgba(25,25,25,0.9); color: #fff;
      padding: 10px 18px; border-radius: 10px; z-index:10; font-family: sans-serif;
      box-shadow: 0 2px 12px #000c;
      user-select: none;
    }
    #controls label { margin-right: 6px; }
    #controls input[type=range] { width: 80px; }
  </style>
</head>
<body>
<div id="controls">
  <label>Gravity: <input id="gravity" type="range" min="0" max="2" step="0.01" value="0.4"></label>
  <label>Speed: <input id="speed" type="range" min="0.1" max="2" step="0.01" value="1"></label>
  <label>Pendulums: <input id="numPendulums" type="number" min="1" max="20" value="6" style="width:42px"></label>
  <label>Segments: <input id="numSegments" type="number" min="1" max="15" value="5" style="width:42px"></label>
  <button id="reset">Reset</button>
</div>
<canvas id="pendulum-canvas"></canvas>
<script>
// Canvas setup
const canvas = document.getElementById('pendulum-canvas');
const ctx = canvas.getContext('2d');
let w = window.innerWidth, h = window.innerHeight;
canvas.width = w; canvas.height = h;

// Controls
const gravityRange = document.getElementById('gravity');
const speedRange = document.getElementById('speed');
const pendulumsInput = document.getElementById('numPendulums');
const segmentsInput = document.getElementById('numSegments');
const resetBtn = document.getElementById('reset');

// Parameters
let GRAVITY = parseFloat(gravityRange.value);
let SPEED = parseFloat(speedRange.value);
let NUM_PENDULUMS = parseInt(pendulumsInput.value,10);
let SEGMENTS_PER_PENDULUM = parseInt(segmentsInput.value,10);
const GLOW_BLUR = 16;
const TRAIL_LENGTH = 80;
const SEGMENT_LENGTH = () => Math.min(w, h) / (SEGMENTS_PER_PENDULUM * 2.5);

// Mouse
let mouse = { x: -1000, y: -1000, down: false, dragging: null, offsetX: 0, offsetY: 0 };

// Rainbow helper (HSV to RGB)
function hsv2rgb(h, s, v) {
  let f = (n, k = (n + h/60)%6) => v - v*s*Math.max(Math.min(k,4-k,1),0);
  return [f(5)*255, f(3)*255, f(1)*255];
}
function getRainbowColor(t) {
  // t in [0,1]
  let [r,g,b] = hsv2rgb(360*t, 1, 1);
  return `rgb(${r|0},${g|0},${b|0})`;
}

// Mouse events
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  if (mouse.down && mouse.dragging) {
    mouse.dragging.origin.x = mouse.x + mouse.offsetX;
    mouse.dragging.origin.y = mouse.y + mouse.offsetY;
  }
});
canvas.addEventListener('mousedown', e=>{
  mouse.down = true;
  for (let p of pendulums) {
    if (dist(mouse, p.origin) < 20) {
      mouse.dragging = p;
      mouse.offsetX = p.origin.x - mouse.x;
      mouse.offsetY = p.origin.y - mouse.y;
      break;
    }
  }
});
canvas.addEventListener('mouseup', e=>{
  mouse.down = false;
  mouse.dragging = null;
});
canvas.addEventListener('mouseleave', e=>{
  mouse.x = -1000; mouse.y = -1000; mouse.down = false; mouse.dragging = null;
});

// Controls interaction
gravityRange.addEventListener('input', ()=>{ GRAVITY = parseFloat(gravityRange.value); });
speedRange.addEventListener('input', ()=>{ SPEED = parseFloat(speedRange.value); });
pendulumsInput.addEventListener('change', ()=>{
  NUM_PENDULUMS = parseInt(pendulumsInput.value,10);
  resetPendulums();
});
segmentsInput.addEventListener('change', ()=>{
  SEGMENTS_PER_PENDULUM = parseInt(segmentsInput.value,10);
  resetPendulums();
});
resetBtn.addEventListener('click', resetPendulums);

// Utility
function dist(a, b) { return Math.hypot(a.x-b.x, a.y-b.y); }
function clamp(val, min, max) { return Math.max(min, Math.min(val, max)); }
function lerp(a,b,t){return a + (b-a)*t;}

// Classes
class PendulumSegment {
  constructor(length, angle) {
    this.length = length;
    this.angle = angle;
    this.aVel = 0;
    this.aAcc = 0;
  }
}
class Pendulum {
  constructor(origin, numSegments, colorBase, colorSpeed) {
    this.origin = {...origin};
    this.segments = [];
    for (let i=0;i<numSegments;++i)
      this.segments.push(new PendulumSegment(
        SEGMENT_LENGTH(),
        lerp(Math.PI/3,2*Math.PI/3,Math.random())
      ));
    this.trail = [];
    this.colorBase = colorBase; // 0-1
    this.colorSpeed = colorSpeed; // speed of hue rotation
    this.colorPhase = Math.random(); // offset for color cycling
  }
  // Forward kinematics: returns array of points [origin, ..., tip]
  getPoints() {
    let pts = [this.origin];
    let x = this.origin.x, y = this.origin.y, angle = 0;
    for (let seg of this.segments) {
      angle += seg.angle;
      x += seg.length * Math.sin(angle);
      y += seg.length * Math.cos(angle);
      pts.push({x, y});
    }
    return pts;
  }
  // Physics update: includes collision with mouse
  update(gravity, speed) {
    let pts = this.getPoints();
    let mouseBlock = false;
    // Check collision with mouse (treat mouse as a circle)
    for (let i = 0; i < pts.length-1; ++i) {
      let nearest = nearestPointOnSegment(mouse, pts[i], pts[i+1]);
      if (dist(mouse, nearest) < 22) {
        // Mouse blocks this segment: provide a physical constraint by "pushing" segment tip away
        // Move the tip of segment[i] to just outside the mouse
        let v = {x: pts[i+1].x - mouse.x, y: pts[i+1].y - mouse.y};
        let len = Math.hypot(v.x, v.y);
        if (len < 22) {
          v.x *= (22/len); v.y *= (22/len);
          pts[i+1].x = mouse.x + v.x;
          pts[i+1].y = mouse.y + v.y;
          // Inverse kinematics: update all angles up to this one
          let prev = pts[i];
          let dx = pts[i+1].x - prev.x;
          let dy = pts[i+1].y - prev.y;
          let newAngle = Math.atan2(dx, dy);
          let angleSum = 0;
          for (let j=0;j<=i;++j) angleSum += this.segments[j].angle;
          let diff = newAngle - angleSum;
          this.segments[i].angle += diff;
          this.segments[i].aVel *= 0.5; // dampen velocity
          mouseBlock = true;
        }
      }
    }
    // Standard physics
    let angle = 0;
    for (let i=0;i<this.segments.length;++i) {
      let seg = this.segments[i];
      // Torque from gravity
      let totalAngle = 0; for (let j=0;j<=i;++j) totalAngle += this.segments[j].angle;
      seg.aAcc = -gravity / seg.length * Math.sin(totalAngle);
      seg.aVel += seg.aAcc * speed;
      seg.aVel *= 0.995; // friction
      seg.angle += seg.aVel * speed;
    }
  }
  // Draw pendulum and trail
  draw(ctx, time) {
    // Animate rainbow color
    let hue = (this.colorBase + this.colorSpeed * time/4000 + this.colorPhase)%1;
    let pts = this.getPoints();

    // Trail
    this.updateTrail(pts[pts.length-1]);
    this.drawTrail(ctx);

    // Draw segments
    ctx.save();
    ctx.shadowBlur = GLOW_BLUR;
    ctx.shadowColor = "#fff";
    for (let i=0;i<pts.length-1;++i) {
      let t = (hue + i/pts.length)%1;
      ctx.strokeStyle = getRainbowColor(t);
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(pts[i].x, pts[i].y);
      ctx.lineTo(pts[i+1].x, pts[i+1].y);
      ctx.stroke();
      // Joint
      ctx.beginPath();
      ctx.arc(pts[i+1].x, pts[i+1].y, 11, 0, 2*Math.PI);
      ctx.fillStyle = getRainbowColor((t+0.12)%1);
      ctx.shadowColor = getRainbowColor((t+0.12)%1);
      ctx.fill();
    }
    // Draw base vertex as a large white circle if hovered
    ctx.beginPath();
    ctx.arc(this.origin.x, this.origin.y, 18, 0, 2*Math.PI);
    ctx.fillStyle = dist(mouse, this.origin)<20 ? '#fff' : '#aaa';
    ctx.shadowBlur = GLOW_BLUR*1.3;
    ctx.shadowColor = "#fff";
    ctx.fill();
    ctx.restore();
  }
  updateTrail(pt){
    this.trail.push({x: pt.x, y: pt.y});
    if (this.trail.length > TRAIL_LENGTH) this.trail.shift();
  }
  drawTrail(ctx) {
    if (this.trail.length < 2) return;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = 4;
    for (let i=1; i<this.trail.length; ++i) {
      let alpha = i / this.trail.length;
      ctx.strokeStyle = `rgba(255,255,255,${alpha*0.45})`;
      ctx.beginPath();
      ctx.moveTo(this.trail[i-1].x, this.trail[i-1].y);
      ctx.lineTo(this.trail[i].x, this.trail[i].y);
      ctx.stroke();
    }
    ctx.restore();
  }
}

// Helper: Closest point on segment ab to point p
function nearestPointOnSegment(p, a, b) {
  let dx = b.x-a.x, dy = b.y-a.y;
  if (dx===0 && dy===0) return {x:a.x, y:a.y};
  let t = ((p.x-a.x)*dx + (p.y-a.y)*dy)/(dx*dx + dy*dy);
  t = clamp(t, 0, 1);
  return {x: a.x + t*dx, y: a.y + t*dy};
}

// Pendulums array and reset
let pendulums = [];
function resetPendulums() {
  pendulums = [];
  let margin = w/(NUM_PENDULUMS+1);
  for (let i=0; i<NUM_PENDULUMS; ++i) {
    let colorBase = Math.random();
    let colorSpeed = 0.25 + Math.random()*0.5;
    pendulums.push(new Pendulum(
      {x: margin*(i+1), y: h/8 + Math.random()*h/10},
      SEGMENTS_PER_PENDULUM,
      colorBase, colorSpeed
    ));
  }
}
window.addEventListener('resize', ()=>{
  w = window.innerWidth; h = window.innerHeight;
  canvas.width = w; canvas.height = h;
  resetPendulums();
});

// Animation
function animate(time) {
  ctx.clearRect(0,0,w,h);
  for (let p of pendulums) {
    if (!mouse.dragging || mouse.dragging !== p)
      p.update(GRAVITY, SPEED);
    p.draw(ctx, time||0);
  }
  requestAnimationFrame(animate);
}

// Init
resetPendulums();
animate();

</script>
</body>
</html>
